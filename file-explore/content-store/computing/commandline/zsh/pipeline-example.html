<h5>Demonstrative pipe example</h5>
<p><img src="/computing/commandline/zsh/graphics/pipeline_example.png" alt="pipeline_example" />
Above is the partial output of the command <code>$ ls /bin /usr/bin</code>. These are the binary executables in the file system.
Say, we wanted to remove the white text.
<code>$ ls /bin /usr/bin |grep -v '/bin:$'</code>
<strong>Aside</strong>, <code>:</code> (colon) is a literal colon and is not a meta-character.
The <code>-v</code> or <code>--invert-match</code> means, everything that does not match the grep string will be printed to standard out.</p>
<div class="code-block"><span class="code-lang">shell</span><button class="copy-btn" aria-label="Copy code">Copy</button><pre><code class="language-shell"> $ ls /bin /usr/bin |grep -v '/bin:$'
[
bash
cat
chmod
cp
csh
dash
date
...
test
unlink
wait4path
zsh
...
AssetCacheLocatorUtil
AssetCacheManagerUtil
AssetCacheTetheratorUtil
DeRez
GetFileInfo
IOAccelMemory
IOMFB_FDR_Loader 
IOSDebug
ResMerger 
...
</code></pre></div>
<p>The above snippet is partial output from the command. Notice the ellipsis. The pesky newline after the <code>zsh</code> line is apart of the real output. Lets remove that line by a new pipe and a <code>grep</code>
<code>$ ls /bin /usr/bin |grep -v '/bin:$'|grep -v '^$'</code>
Understanding the regex: <code>'^$'</code>
<code>^</code> starting at the beginning of the line then match <em>nothing</em> til the end of the line <code>$</code>. In tandem with the <code>-v</code> option this will output all the lines that do not match a blank line.</p>
<h6><code>column</code><em>ize</em> the output</h6>
<p>given <code>proglist</code>, a file of the all the available commands defined as...
<code>$ /bin/ls /bin /usr/bin | grep -v '/bin:$' | grep -v '^$' | sort &gt; proglist</code>
<code>$ cat proglist</code></p>
<div class="code-block"><button class="copy-btn" aria-label="Copy code">Copy</button><pre><code>AssetCacheLocatorUtil
AssetCacheManagerUtil
AssetCacheTetheratorUtil
DeRez
GetFileInfo
IOAccelMemory
IOMFB_FDR_Loader
IOSDebug
ResMerger
...
</code></pre></div>
<p>The above is partial output. Notice the ellipsis.
<code>$ column proglist</code>
when given with no options will pick how many columns based off the current terminal size (the width of the window).
<code>$ column -c 50 proglist</code>
the <code>-c</code> option will output columns based on the hardcoded specifications of a terminal window being 50 columns wide.</p>
<h6><code>cut</code>ing off excess characters</h6>
<p><code>$ head proglist | cut -c 1-7</code>
<strong>Aside</strong>, <code>head</code> outputs the first ten lines. Then, <code>cut</code> based off characters (<code>-c</code>). The above command outputs the first 7 characters of each line.
<strong>Oops</strong> I mean to get the fist 9 characters, not 7. Perfect time for the <strong>history substitution operator</strong> <code>^n^n</code>
<code>$ ^7^9</code></p>
<h6>Get all programs (lines) that end in 'sh'</h6>
<p><code>$ grep 'sh$' proglist</code></p>
<div class="code-block"><button class="copy-btn" aria-label="Copy code">Copy</button><pre><code>afhash
bash
chsh
crlrefresh
csh
dash
hash
instmodsh
ksh
mcxrefresh
power_report.sh
sh
ssh
</code></pre></div>
<p>Modify the above command so that the commands that end in '.sh' are omitted. Good use case for <code>egrep</code> that accepts extended regular expressions. <code>grep -E</code> is the same as <code>egrep</code>.
<code>$ egrep '[^.]sh$' proglist</code></p>
<h6>Conditional or in egrep's regex</h6>
<p><code>$ egrep '[^.]sh$|ch$' proglist</code>
The above command shows the regex or conditional which happens to be a pipe as well! A conditional and is achieved by separating out the conditions in different passes of the <code>grep</code> command. Yes, multiple pipelines of <code>grep</code> are necessary to achieve this.</p>
<h6><code>ls</code> (list) the contents of each directory in the <code>PATH</code></h6>
<p>Given, the below command will outputs the paths in an arguments friendly way.
<code>$ echo ${PATH}|tr ':' ' '</code>
<strong>translate</strong> the characters from standard input. Specifically, for replace every colon with a space. Then with <strong>command substitution</strong> we put the standard output of the command on the command line as arguments (not through pipes as standard input). <strong>Command substitution</strong> is done with backticks. Think of it as an in-place substitution.</p>
<div class="code-block"><span class="code-lang">shell</span><button class="copy-btn" aria-label="Copy code">Copy</button><pre><code class="language-shell">$ ls `echo ${PATH}|tr ':' ' '`
</code></pre></div>
<h6>Alternative with loops</h6>
<p>See more in <a href="/computing/commandline/zsh/loops.html">Loops</a></p>
<div class="code-block"><span class="code-lang">shell</span><button class="copy-btn" aria-label="Copy code">Copy</button><pre><code class="language-shell">for dir in  `echo ${PATH}|tr ':' ' '`
do
	ls $dir
done
</code></pre></div>
<h6>Got errors?</h6>
<p>Redirect to the standard error to the 'waste bin' (<code>/dev/null</code>)
Direct the '2' stream (file descriptor) to standard error. Modify the <code>ls</code> line with the below.
<code>ls $dir 2&gt; /dev/null</code></p>
<h6>More robust script will only call <code>ls</code> on directories</h6>
<p>A simple check (<code>test</code>) before the call to <code>ls</code> will suffice.
The above for loop naively calls <code>ls</code> on everything in the <code>PATH</code>. Lets make sure the for variable is a directory before calling <code>ls</code></p>
<div class="code-block"><span class="code-lang">shell</span><button class="copy-btn" aria-label="Copy code">Copy</button><pre><code class="language-shell">for dir in  `echo ${PATH}|tr ':' ' '`
do
	if [ -d $dir ]
	then
		ls $dir
	fi
done
</code></pre></div>
